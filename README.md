# HW2

# شرح آزمایش 

در پروژه موردنظر از یک کلاس abstract تحت عنوان Shape استفاده کردیم که این کلاس به عنوان یک توصیف از مشخصات یکسان برای شکل‌های مختلف استفاده می‌شود. به عبارتی دیگر متدهایی مانند محاسبه مساحت یا محاسبه محیط یک شکل که بایستی در تمامی کلاس‌ها شکل مانند مربع و مستطیل پیاده‌سازی شود، ابتدا در این کلاس abstract تعریف شده ولی پیاده‌سازی نمی‌شود. به عبارتی دیگر توصیف متد موردنظر در کلاس abstract انجام شده ولی پیاده‌سازی آن در خود زیرکلاس‌های مربوطه انجام می‌گیرد. به عنوان مثال در پروژه مفروض متد ()computeArea در کلاس ابسترکت Shape توصیف می‌شود ولی نحوه پیاده‌سازی آن چون برای هر شکل هندسی متفاوت بوده و وابسته به پارامترهای مختلفی است، در خود کلاس‌های اشکال هندسی انجام می‌شود. این مورد در راستای اصل OCP از مجموعه اصول SOLID صورت گرفته است. در این حالت اگر بخواهیم به راحتی می‌توانیم یک شکل هندسی دیگر مانند مثلث را به مسئله اضافه کنیم. در این حالت محتویات کدی که پیش از این در کلاس‌های دیگر زده‌ایم دست نخورده باقی می‌ماند و صرفا کافی است که یک کلاس جدید تحت عنوان Triangle به پروژه اضافه کرده و آن را فرزند کلاس Shape قرار دهیم. هم‌چنین در نهایت بایستی متدهای تعریف شده در کلاس Shape را در کلاس جدید پیاده‌سازی کرده و در صورت لزوم متدهایی مخصوص به خود آن کلاس نیز در آن اضافه کنیم. بنابراین در این حالت، ما نسبت به گسترش پروژه خود باز هستیم (open to extension) ولی نسبت به تغییر کد بسته خواهیم بود (closed for modification) زیرا به راحتی می‌توانیم با اضافه کردن کلاسی جدید به مسئله، بدون نیاز به تغییر کدهای قبلی، پروژه خود را برای سایر اشکال هندسی نیز گسترش دهیم. بنابراین قاعده OCP به شکل گفته شده در پروژه رعایت شده است. 

در رابطه با اصل SRP نیز واضح است که در پروژه تعریف شده هر یک از کلاس‌های موجود (که شامل کلاس مربع و مستطیل می‌باشند؛ در صورتی که کلاس ابسترکت Shape را در نظر نگیریم) صرفا یک مسئولیت به عهده دارند و صرفا به خاطر ایجاد تغییر در یک مسئولیت و وظیفه مشخص تغییر می‌کنند. به عنوان مثال، کلاس Rectangle در پروژه موردنظر صرفا یک مسئولیت دارد، یعنی نمایش یک مستطیل و انجام عملیات اساسی مربوط به ابعاد و محاسبه مساحت آن. همان‌طور که واضح است این کلاس کارکردها یا مسئولیت‌های نامرتبط ندارد و صرفا به علت ایجاد تغییر در عملیات‌های اساسی مربوط به یک مستطیل دستخوش تغییر می‌شود. بنابراین در مسئله موردنظر اصل SRP نیز رعایت شده است.

در حالی که مربع نوع خاصی از مستطیل در ریاضیات است، کلاس‌هایی که آن اشکال را نشان می‌دهند، اگر می‌خواهید با اصل جایگزینی لیسکوف مطابقت داشته باشند، نباید در رابطه والد-فرزند باشند. یکی از راه‌های حل این مشکل، ایجاد یک کلاس پایه برای گسترش هر دو Rectangle و Square است. در این حالت کلاس Shape به یک type تبدیل می‌شود که این امکان وجود دارد که از طریق polymorphism آن را با مستطیل یا مربع جایگزین کنید. توجه داشته باشید که هر دو نوع Shape در این مسئله دارای مجموعه‌های مشخصی از ویژگی‌ها می‌باشند، اما دارای ‌متدهای initializer متفاوت هستند و به طور بالقوه می‌توانند حتی رفتارهای جداگانه‌تری را پیاده‌سازی کنند. تنها وجه مشترک آنها توانایی محاسبه مساحت آن‌هاست. با این پیاده سازی، می توانید از نوع Shape به جای زیرگروه مربع و مستطیل آن استفاده کنید، زمانی که فقط به رفتار مشترک آنها اهمیت می دهید. بنابراین به این شکل اصل LCP از مجموعه قواعد SOLID در مسئله پیاده‌سازی شده است.


# 1
Single Responsibility Principle

این قانون که به طور خلاصه SRP نیز نامیده می‌شود، حاکی از آن است که یک کلاس باید صرفاً یک وظیفه بیشتر نداشته باشد که در این صورت، کلاس‌ها فقط و فقط به خاطر ایجاد تغییر در وظیفه‌ای که انجام می‌دهند دستخوش تغییر خواهند شد نه چیز دیگر! کلاس‌ها می‌توانند فیچرهای مختلفی داشته باشند اما تمامی آن‌ها باید مربوط به یک حوزه بوده و مرتبط به هم باشند که در نهایت با محترم شمردن چنین قانونی، برنامه‌نویسان دیگر قادر نخواهند بود تا کلاس‌های اصطلاحاً همه‌فن‌حریف بنویسند.

Open-Closed Principle

هر کلاسی باید برای توسعه یافتن قابلیت‌هایش اصطلاحاً Open بوده و دست برنامه‌نویس برای افزودن فیچرهای جدید به آن باز باشد اما اگر وی خواست تا تغییری در کلاس ایجاد کند، چنین امکان باید Closed بوده و او اجازهٔ چنین کاری را نداشته باشد. فرض کنیم نرم‌افزاری نوشته‌ایم که دارای چندین کلاس مختلف است و نیازهای اپلیکیشن‌مان را مرتفع می‌سازند اما به جایی رسیده‌ایم که نیاز داریم قابلیت‌های جدید به برنامهٔ خود بیفزاییم. بر اساس این قانون، دست‌مان برای تغییر یا بهتر بگوییم افزودن فیچرهای جدید به کلاس مد نظر باز است در حالی که این قابلیت‌های جدید باید در قالب افزودن کدهای جدید صورت پذیرد نه ریفکتور کردن و تغییر کدهای قبلی!

Liskov Substitution Principle

این اصل حاکی از آن است که کلاس‌های فرزند باید آن‌قدر کامل و جامع از کلاس والد خود ارث‌بری کرده باشند که به سادگی بتوان همان رفتاری که با کلاس والد می‌کنیم را با کلاس‌های فرزند نیز داشته باشیم به طوری که اگر در شرایطی قرار گرفتید که با خود گفتید کلاس فرزند می‌تواند تمامی کارهای کلاس والدش را انجام دهد به جزء برخی موارد خاص، اینجا است که این اصل از SOLID را نقض کرده‌اید.

Interface Segregation Principle

پیش از این هم گفتیم که اینترفیس‌ها فقط مشخص می‌کنند که یک کلاس از چه متدهایی حتماً باید برخوردار باشد. در همین راستا و بر اساس این قانون، چندین اینترفیس تک‌منظوره به مراتب بهتر است از یک اینترفیس چندمنظوره است به طوری که اگر یک اینترفیس چندمنظورهٔ کامل و جامع داشته باشیم و سایر کلاس‌های ما از آن اصطلاحاً `implements` کنند،‌ در چنین صورتی ممکن است برخی خصوصیات، متدها و رفتارها را به برخی کلاس‌هایی که اصلاً نیازی به آن‌ها ندارند تحمیل کنیم اما اگر از چندین اینترفیس تخصصی استفاده کنیم، به سادگی می‌توانیم از هر اینترفیسی که نیاز داشته باشیم در کلاس‌های مد نظر خود استفاده نماییم و در صورتی هم کلاسی وجود داشت که نیاز به استفاده از چندین اینترفیس مختلف داشت، دست ما باز خواهد بود تا آن کلاس را از چندین اینترفیس `implements` کنیم.

Dependency Inversion Principle

کلاس‌هایی که سطح بالا هستند، به کلاس‌های سطح پایین وابستگی نداشته باشند؛ هردوی آن‌ها باید وابسته به انتزاع (Abstractions) باشند. موارد انتزاعی وابسته به جزئیات نباشند، جزئیات باید وابسته به انتزاع باشند. به طور خلاصه، در OOP باید تمام تلاش خود را به کار بندیم تا Dependency (وابستگی) را مابین کلاس‌ها، ماژول‌ها و آبجکت‌های سطح بالا با ماژول‌های سطح پایین به حداقل برسانیم که با این کار، اِعمال تغییرات در آینده به مراتب راحت‌تر صورت خواهد پذیرفت.

# 2

اصول SOLID در درجه اول در مراحل طراحی و پیاده سازی ایجاد نرم افزار اعمال می شود. در حقیقت ، اگر بخواهیم به طور درستی از اصول SOLID و در مرحله‌ای درست از توسعه نرم‌افزار از این اصول استفاده کنیم، بایستی در مرحله طراحی از این اصول استفاده کنیم. در طول مرحله طراحی، توسعه دهندگان از اصول SOLID برای ایجاد یک معماری انعطاف پذیر و قابل نگهداری برای نرم افزار استفاده می کنند. در مرحله پیاده سازی، توسعه دهندگان به اصول تعریف شده در مرحله طراحی برای نوشتن کد تمیز و قابل نگهداری پایبند هستند. با پیروی از اصول SOLID، توسعه‌دهندگان اطمینان حاصل می‌کنند که کلاس‌ها و ماژول‌ها دارای مسئولیت‌های به‌خوبی تعریف شده‌اند و همین مورد درک، اصلاح و نگهداری کد را آسان‌تر می‌سازد.

اصول SOLID در درجه اول بر روی شیوه‌های طراحی و کدگذاری توسعه نرم‌افزار تأثیر می‌گذارد و منجر به طراحی سیستم‌های قابل نگهداری، انعطاف‌پذیر و مقیاس‌پذیرتر می‌شود. در حالی که عناصر اصول SOLID ممکن است در طی مراحل دیگری مانند تجزیه و تحلیل و استخراج نیازمندی‌ها نیز در نظر گرفته شوند.

# 3

خیر، این دو رویکرد متناقض نیستند. بلکه متدولوژی های مختلفی را برای توسعه نرم افزار نشان می‌دهند و در زمینه های مربوط به خود معتبر و مفید هستند. در حالی که چرخه توسعه سنتی توسعه نرم‎‌افزار ابتدا با پیاده‌سازی (`implementation`) شروع می‌شود و سپس به تست می‌پردازد، در روش و رویکرد TDD این ترتیب معکوس شده و فرایند توسعه نرم‌افزار با نوشتن تست‌ها قبل از وجود کد و پیاده‌سازی شروع می‌شود. با این حال، ایده کلیدی در TDD این است که هم تست و هم پیاده‌سازی بخش‌های جدایی‌ناپذیر فرآیند توسعه هستند و پیوسته با هم تعامل دارند. در TDD، نوشتن تست‌ها در ابتدا به روشن شدن رفتار و عملکرد مطلوب کد قبل از پیاده‌سازی کمک می‌کند. به همین دلیل در این رویکرد این به عنوان یک `specification` عمل می‌کند و توسعه‌دهندگان را در ایجاد کدی که آن الزامات را برآورده می می‌سازد راهنمایی می‌کند. TDD توسعه تدریجی را ارتقا می‌دهد، جایی که هر ویژگی جدید بر اساس موارد آزمایشی خاص توسعه می‌یابد و منجر به کد قابل اعتمادتر و قابل نگهداری می‌شود.

چرخه توسعه سنتی و رویکرد TDD در ترتیب فعالیت ها متفاوت می‌باشند، اما با یک‌دیکر متناقض نیستند. TDD یک روش خاص است که از ابتدا آزمایش را در بر می‌گیرد و با ارائه دیدگاهی متفاوت در مورد چگونگی اطمینان از کیفیت و عملکرد کد، چرخه توسعه سنتی را تکمیل می‌کند. هر دو روش مزایای خود را دارند و بسته به نیازهای پروژه و ترجیحات تیم می توان از آن‌ها استفاده کرد.

# 4

در آزمایش فوق، که کلاس‌های Rectangle و Square را پیاده‌سازی کرده‌ایم، به دلیل تفاوت‌های اساسی در رفتارها و ویژگی‌های آنها، ارث بردن Square از Rectangle توصیه نمی‌شود. وراثت معمولاً زمانی استفاده می شود که یک رابطه `is-a` بین دو کلاس وجود داشته باشد، به این معنی که کلاس مشتق شده (زیر کلاس) را می توان یک نسخه تخصصی از کلاس پایه (superclass) در نظر گرفت. با این حال، مربع یک نسخه تخصصی از یک مستطیل به معنای متعارف نیست. تفاوت اصلی بین یک مستطیل و یک مربع در نحوه استفاده از ابعاد آنها نهفته است. یک مستطیل دارای دو بعد مستقل عرض و ارتفاع است که می‌توان آن‌ها را با مقادیر مختلف تنظیم کرد. از طرف دیگر، یک مربع فقط یک بعد دارد، طول ضلع، و یک حالت خاص از یک مستطیل است که در آن همه اضلاع برابر هستند.

دذ این حالت اگر بخواهیم که کلاس Square را از Rectangle به ارث ببریم، چندین ایراد و مشکل به وجود آمده و همین امر سبب  نقض اصل  LSP می‌شود. در این صورت حتی اگر فرض کنیم که در مستطیل متد تغییر طول و عرض وجود نداشته باشد هم با ارث‌بردن کلاس Square از کلاس Rectangle مشکلاتی به وجود می‌آید. اصلی‌ترین مشکل زمانی است که بخواهیم یک متد جدید دیگر در کلاس Rectangle ایجاد کنیم که این متد مخصوص به همین کلاس بوده و نحوه پیاده‌سازی آن در کلاس Sqaure متفاوت باشد. در این حالت باز هم بایستی اصل LSP در از مجموعه قواعد SOLID را نقض کنیم. به همین دلیل ارث‌بری کلاس Square از کلاس Rectangle تحت شرایط بیان شده، که در کلاس مستطیل متدهای تغییر طول و عرض نداشته باشیم، توصیه نمی‌شود زیرا در ادامه فرایند توسعه برنامه موردنظر ممکن است که شرایطی پیش بیاید که در آن نیاز باشد تا متدی جدید در کلاس مستطیل پیاده‌سازی کنیم و متد موردنظر مخصوص به مستطیل باشد و برای پیاده‌سازی آن در کلاس مربع مجبور به تغییر آن باشیم.
